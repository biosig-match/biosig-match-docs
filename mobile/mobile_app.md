---
service_name: "Smartphone App"
description: "ユーザーインターフェースを提供し、ファームウェアとサーバー群を繋ぐ中継ハブ。"
inputs:
  - source: "ファームウェア (BLE)"
    data_format: "BLE Notify (Compressed Sensor Data)"
    schema: "Zstandard圧縮されたバイナリデータ"
  - source: "ユーザー"
    data_format: "UI操作"
    schema: "実験開始/終了、実験ID選択など"
  - source: "各種サーバーAPI"
    data_format: "JSON"
    schema: "リアルタイム解析結果、実験リストなど"
outputs:
  - target: "Collectorサービス"
    data_format: "HTTP POST (JSON)"
    schema: "{ user_id, payload_base64 }"
  - target: "Session Managerサービス"
    data_format: "HTTP POST/GET (JSON)"
    schema: "実験作成リクエスト、セッション終了通知など"
  - target: "Realtime Analyzerサービス"
    data_format: "HTTP GET (JSON)"
    schema: "自身のユーザーIDに紐づく解析結果の要求"
---

## 概要

本アプリは、ユーザーが実験やセッションを管理するための UI を提供します。BLE 経由でファームウェアから圧縮された生データを受け取り、**ユーザー ID**のみを付与して`Collector`サービスに転送します。セッション管理やタイムスタンプ同期の役割も担います。

## 詳細

### データ中継

- **責務**: ファームウェアから受け取った圧縮データを、**解凍せずに**そのままサーバーへ送信します。
- **処理フロー**:
  1.  BLE で受信した圧縮バイナリデータを Base64 エンコードする。
  2.  自身の `user_id` と共に JSON オブジェクトを作成する。
  3.  `Collector`サービスの`/api/v1/data`エンドポイントに HTTP POST で送信する。
- **背景**: アプリの責務はデータの中継に徹するべきです。圧縮データの解凍・解析といった重い処理をクライアントサイドで行うと、パフォーマンスの低下やバッテリーの過剰消費に繋がります。ペイロードを不透明なデータ(Opaque)として扱うことで、アプリの実装をシンプルに保ち、将来ファームウェアのデータ形式が変更されてもアプリ側の改修を不要にします。

### セッション管理

- **責務**: `Session Manager`と連携し、実験とセッションのライフサイクルを管理する。
- **処理フロー**:
  1.  **セッション開始時**: `Session Manager`から実験リストを取得し、ユーザーに選択させる（または新規作成させる）。
  2.  **セッション ID 生成**: セッション ID をクライアントサイドで生成する。命名規則は`{user_id}-{start_unix_ms}-{end_unix_ms}`とする。
  3.  **メディアデータ送信**: セッション中に撮影した画像や音声には、`user_id`と`session_id`を付与して`Processor`サービス（または専用エンドポイント）に直接アップロードする。
  4.  **セッション終了時**: ユーザーが UI でセッションを終了させると、`Session Manager`に`session_id`、開始/終了時刻、実験 ID などの情報を送信する。

### タイムスタンプ同期

- **責務**: ファームウェアとのクロックのズレ（オフセット）を計算し、サーバーに提供する。
- **処理フロー**:
  1.  セッション開始時およびセッション中に定期的（例: 1 分ごと）に、ファームウェアに対して Ping-Pong 処理を実行する。
  2.  往復時間(RTT)を利用してオフセットを計算する。最も RTT が小さかった結果をその時点での信頼できるオフセット値とする。
  3.  計算したオフセット値と、その計算が完了した時点の UNIX 時間をペアにして、`Processor`サービス（または専用エンドポイント）に送信する。
- **背景**: 正確なデータ同期のためには、収集されたデータのタイムスタンプを単一の信頼できるクロック（サーバーの UTC 時刻）に正規化する必要があります。この処理により、後段の`Processor`がその正規化を行うための補正情報を提供します。
